use crate::parser::tokens::{Token, LexicalError};
use std::collections::HashMap;
use crate::directory::{FunctionDirectory, FunctionInfo};
use crate::ast;


grammar;

extern {
  type Location = usize;
  type Error = LexicalError;

  enum Token {
    "program" => Token::KeywordProgram,
    "main" => Token::KeywordMain,
    "end" => Token::KeywordEnd,
    "identifier" => Token::Identifier(<String>),
    "var" => Token::KeywordVar,
    "print" => Token::KeywordPrint,
    "void" => Token::KeywordVoid,
    "if" => Token::KeywordIf,
    "else" => Token::KeywordElse,
    "do" => Token::KeywordDo,
    "while" => Token::KeywordWhile,

    "KeywordInt" => Token::KeywordInt,
    "KeywordFloat" => Token::KeywordFloat,

    "KeywordCTEInt" => Token::KeywordCTEInt,
    "KeywordCTEFloat" => Token::KeywordCTEFloat,
    "cte.string" => Token::CteString,
    "int" => Token::Integer(<i64>),
    "float" => Token::Float(<f64>),

    "(" => Token::LParen,
    ")" => Token::RParen,
    "{" => Token::LBracket,
    "}" => Token::RBracket,
    "[" => Token::LSQRBracket,
    "]" => Token::RSQRBracket,
    "=" => Token::Assign,
    ";" => Token::Semicolon,
    ":" => Token::Colon,
    "," => Token::Comma,
    "\"" => Token::Quote,

    "+" => Token::OperatorAdd,
    "-" => Token::OperatorSub,
    "*" => Token::OperatorMul,
    "/" => Token::OperatorDiv,

    ">" => Token::BiggerThan,
    "<" => Token::LessThan,
    "!=" => Token::NotEqual,
  }
}

// Top-level parse
pub Script: Box<FunctionDirectory> = {
  <start:Program> => start
}

// El programa es Header, DecVars, DecFuncs y por ultimo Body
pub Program: Box<FunctionDirectory> = {
  <header:Header> <vars:DecVars> <funcs:DecFuncs> "main" <body:Body> "end" => {
    //Crea directorio de funciones
    let mut oFuncDirectory = FunctionDirectory::new();

     // Crea la función main
    let mut oFunctionInfoMain = FunctionInfo::new("void".to_string());

    for (sName, sType) in vars {
        if oFunctionInfoMain.oVariableDirectory.contains_key(&sName) {
            panic!("Variable '{}' already declared", sName); // Validación
        }      

        oFunctionInfoMain.oVariableDirectory.insert(sName, sType);
    }
    //Genera tabla de variables de la funcion main y  se guarda en mi directorio de funciones
    oFuncDirectory.oFunctions.insert("main".to_string(), oFunctionInfoMain);

    for (sFuncName, oFunctInfo) in funcs {
        if oFuncDirectory.oFunctions.contains_key(&sFuncName) {
            panic!("Function '{}' already declared", sFuncName); // Validación
        }      
        // Validar variables globales con variables de funciones (habra alguna manera que sea mas eficiente?) 
        for sVarName in oFunctInfo.oVariableDirectory.keys() {
            if oFuncDirectory.oFunctions["main"].oVariableDirectory.contains_key(sVarName) {
                panic!(
                    "Variable '{}' in function '{}' already exists as a global variable.",
                    sVarName, sFuncName
                );
            }
        }

        oFuncDirectory.oFunctions.insert(sFuncName, oFunctInfo);
    }
    Box::new(oFuncDirectory)


  }
}

//Header Inicial
Header: String = {
  "program" <id:"identifier"> ";" => {
    format!("ProgramDeclaration({})", id)
  }
}

// Body
Body: Vec<String> = {
  "{" <state:DecStatement> "}" => {
    let v = state;
    v
  }
}

// Statement

DecStatement: Vec<String> = {
  => vec![],
  <assign:Assign><ds:DecStatement> => vec![assign],
  <condition:Condition><ds:DecStatement> => vec![condition],
  <cycle:Cycle><ds:DecStatement> => vec![cycle],
  <fCall:FCall><ds:DecStatement> => vec![fCall],
  <print:Print><ds:DecStatement> => vec![print]

}

Assign: String = {
  <id: "identifier"> "=" <exp:Expresion> ";" => {
    format!("Asignacion({}, {})", id, exp)
  }
}

Condition: String = {
  "if" "(" <exp:Expresion> ")" "do" <b:Body> <e:Else> ";" => {
    format!("Condicion({}, {})", exp,  e )
  }
}

Else: String = {
  => "None Else".to_string(),
  "else" <b:Body> => format!("Else()")
}

Cycle: String = {
  "while" "(" <exp:Expresion> ")" "do" <b:Body> ";" => {
    format!("Cycle({})", exp)
  }
}

FCall: String = {
  <id: "identifier"> "(" <de:DecExpresion> ")" ";"=> {
    format!("FCall({})", id)
  }
}

Print: String = {
  "print" "(" <pt:PrintTipo> ")" ";"=> {
    format!("Print({})", pt)
  }
}

PrintTipo: String = {
  <exp:Expresion><pe:PrintExtra> => {
     exp
  },
  <val:"cte.string"> <pe:PrintExtra> => {
     "String".to_string()
  }
}

PrintExtra: String = {
  => "".to_string(),
  "," <print:PrintTipo> => {
     print
  }
}

// Variables

pub DecVars: Vec<(String,String)> = {
  => vec![],
  <var:Vars> <rest:DecVars> => {
    let mut v = var;
    v.extend(rest);
    v
  }
}

Vars: Vec<(String, String)> = {
  "var" <vars:Variable> ":" <tpe:Type> ";" => {
    //Para cada id de vars va a generar un valor en el vector con (id, type)
    vars.into_iter().map(|id| (id, tpe.clone())).collect()
  }
}


Variable: Vec<String> = {
  <name:"identifier"> <more:MASIDS> => {
    let mut ids = vec![name];
    ids.extend(more);
    ids
  }
}

MASIDS: Vec<String> = {
  => vec![],
  "," <name:"identifier"> <more:MASIDS> => {
    let mut ids = vec![name];
    ids.extend(more);
    ids
  }
}


// Funciones

// Funciones: cero o más (Nombre, Info Funcion)
pub DecFuncs: Vec<(String, FunctionInfo)> = {
  => vec![],
  <func:Funcs> <rest:DecFuncs> => {
    let mut v = func;
    v.extend(rest);
    v
  }
}

// Una función (Nombre, Info Funcion)
Funcs: Vec<(String, FunctionInfo)> = {
  "void" <name:"identifier"> "(" <params:DecParametros> ")" "[" <vars:DecVars> <body:Body> "]" ";" => {
    //format!("DeclaracionFuncion({}, {:?}, {:?}, {:?})", name, params, vars, body)
    let mut oFunctionInfo = FunctionInfo::new("void".to_string());
    let mut v = params;
    v.extend(vars);
    // Declaracion parametros y variables dentro de funcion
    for (sName, sType) in v {
        if oFunctionInfo.oVariableDirectory.contains_key(&sName) {
            panic!("Variable '{}' already declared", sName); // Validación
        }      

        oFunctionInfo.oVariableDirectory.insert(sName, sType);
    }

    vec![(name,oFunctionInfo)]
  }
}

// Parametros

DecParametros: Vec<(String, String)> = {
  => vec![],
  <p:Param> <rest:MASPARAMS> => {
    let mut v = p;
    v.extend(rest);
    v
  }
}

Param: Vec<(String, String)> = {
  <id:"identifier"> ":" <tpe:Type> => {
    vec![(id, tpe)]
  }
}

MASPARAMS: Vec<(String, String)> = {
  => vec![],
  "," <p:Param> <rest:MASPARAMS> => {
    let mut v = p;
    v.extend(rest);
    v
  }
}

// DecExpresion maneja listas separadas por coma
DecExpresion: Vec<String> = {
  => vec![],
  <exp:Expresion> <rest:MASEXPRESIONES> => {
    let mut v = vec![exp];
    v.extend(rest);
    v
  }
}

MASEXPRESIONES: Vec<String> = {
  => vec![],
  "," <exp:Expresion> <rest:MASEXPRESIONES> => {
    let mut v = vec![exp];
    v.extend(rest);
    v
  }
}

// Expresion 
Expresion: String = {
  <exp:EXP> <tipo:TipoExp> => {
    format!("Expresion({}, {})", exp, tipo)
  }
}

// Operadores relacionales
TipoExp: String = {
  => "None".to_string(),
  ">" <exp:EXP> => format!("Relacional(>, {})", exp),
  "<" <exp:EXP> => format!("Relacional(<, {})", exp),
  "!=" <exp:EXP> => format!("Relacional(!=, {})", exp),
}

// Expresión aritmética básica
EXP: String = {
  <lhs:Termino> <rhs:TerminoDerecha> => {
    if rhs.is_empty() {
      lhs
    } else {
      format!("Aritmetica({}, {})", lhs, rhs)
    }
  }
}

// Un solo término
Termino: String = {
  <lhs:Factor><rhs:FactorDerecha> => {
    if rhs.is_empty() {
      lhs
    } else {
      format!("Termino({}, {})", lhs, rhs)
    }
  }
}

// Operadores aritméticos
TerminoDerecha: String = {
  => "".to_string(),
  "+" <t:Termino> => format!("+{}", t),
  "-" <t:Termino> => format!("-{}", t),
}

FactorDerecha: String = {
  => "".to_string(),
  "*" <f:Factor> => format!("*{}", f),
  "/" <f:Factor> => format!("/{}", f),
}

// Factores
Factor: String = {
  "(" <exp:Expresion> ")" => format!("Paren({})", exp),
  <signo:FactorSigno> <val:FactorValor> => format!("Factor({}, {})", signo, val)
}

// Opcionalmente signo + o -
FactorSigno: String = {
  => "".to_string(),
  "+" => "Pos".to_string(),
  "-" => "Neg".to_string(),
}

// Identificador o constante
FactorValor: String = {
  <id:"identifier"> => format!("Id({})", id),
  <cte:CTE> => cte,
}

// Constantes
pub CTE: String = {
  <i:"int"> => format!("IntConst({})", i),
  <f:"float"> => format!("FloatConst({})", f),
}

// Tipos
pub Type: String = {
  "KeywordInt" => "Int".to_string(),
  "KeywordFloat" => "Float".to_string(),
}

// Expresiones aritméticas
pub Expression: Box<ast::Expression> = {
  #[precedence(level="1")]
  Term,

  #[precedence(level="2")] #[assoc(side="left")]
  <lhs:Expression> "*" <rhs:Expression> => {
    Box::new(ast::Expression::BinaryOperation {
      lhs,
      operator: ast::Operator::Mul,
      rhs
    })
  },
  <lhs:Expression> "/" <rhs:Expression> => {
    Box::new(ast::Expression::BinaryOperation {
      lhs,
      operator: ast::Operator::Div,
      rhs
    })
  },

  #[precedence(level="3")] #[assoc(side="left")]
  <lhs:Expression> "+" <rhs:Expression> => {
    Box::new(ast::Expression::BinaryOperation {
      lhs,
      operator: ast::Operator::Add,
      rhs
    })
  },
  <lhs:Expression> "-" <rhs:Expression> => {
    Box::new(ast::Expression::BinaryOperation {
      lhs,
      operator: ast::Operator::Sub,
      rhs
    })
  },
}

// Literales y variables
pub Term: Box<ast::Expression> = {
  <val:"int"> => {
    Box::new(ast::Expression::Integer(val))
  },
  <name:"identifier"> => {
    Box::new(ast::Expression::Variable(name))
  },
  "(" <e:Expression> ")" => e,
}
