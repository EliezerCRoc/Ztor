use crate::parser::tokens::{Token, LexicalError};
use std::collections::HashMap;
use crate::memory::directory::{FunctionDirectory, FunctionInfo};
use crate::memory::variables::VariableValueTable;
use crate::semantic::datatype::{DataType, Value, Operator};
use crate::semantic::quadruples::QuadrupleList;
use crate::ast::Expression;


use crate::ast;


grammar<'input>(oFuncDirectory:&'input mut FunctionDirectory, 
                oVariableValueTable:&'input mut VariableValueTable,
                oQuadrupleList:&'input mut QuadrupleList,);

extern {
  type Location = usize;
  type Error = LexicalError;

  enum Token {
    "program" => Token::KeywordProgram,
    "main" => Token::KeywordMain,
    "end" => Token::KeywordEnd,
    "identifier" => Token::Identifier(<String>),
    "var" => Token::KeywordVar,
    "print" => Token::KeywordPrint,
    "void" => Token::KeywordVoid,
    "if" => Token::KeywordIf,
    "else" => Token::KeywordElse,
    "do" => Token::KeywordDo,
    "while" => Token::KeywordWhile,

    "KeywordInt" => Token::KeywordInt,
    "KeywordFloat" => Token::KeywordFloat,

    "KeywordCTEInt" => Token::KeywordCTEInt,
    "KeywordCTEFloat" => Token::KeywordCTEFloat,
    "cte.string" => Token::CteString,
    "int" => Token::Integer(<i64>),
    "float" => Token::Float(<f64>),

    "(" => Token::LParen,
    ")" => Token::RParen,
    "{" => Token::LBracket,
    "}" => Token::RBracket,
    "[" => Token::LSQRBracket,
    "]" => Token::RSQRBracket,
    "=" => Token::Assign,
    ";" => Token::Semicolon,
    ":" => Token::Colon,
    "," => Token::Comma,
    "\"" => Token::Quote,

    "+" => Token::OperatorAdd,
    "-" => Token::OperatorSub,
    "*" => Token::OperatorMul,
    "/" => Token::OperatorDiv,

    ">" => Token::BiggerThan,
    "<" => Token::LessThan,
    "!=" => Token::NotEqual,
  }
}

// Top-level parse
pub Script: () = {
  <start:Program> => ()
}

// El programa es Header, DecVars, DecFuncs y por ultimo Body
pub Program: () = {
  <header:Header> <vars:DecVars> <funcs:DecFuncs> "main" <body:Body> "end" => {

     // Crea la función main
    let mut oFunctionInfoMain = FunctionInfo::new("void".to_string());

    for (sName, oType) in vars {
        if oFunctionInfoMain.oVariableDirectory.contains_key(&sName) {
            panic!("Variable '{}' already declared", sName); // Validación
        }      
        let mut iIndex = usize::MIN;
        match *oType {
            DataType::Int => {iIndex =  oVariableValueTable.set(Value::Int(0), *oType)},
            DataType::Float => {iIndex =  oVariableValueTable.set(Value::Float(0.0), *oType)},
            DataType::Bool => {iIndex =  oVariableValueTable.set(Value::Bool(false), *oType)}
        };
         


        oFunctionInfoMain.oVariableDirectory.insert(sName, iIndex);


    }
    //Genera tabla de variables de la funcion main y  se guarda en mi directorio de funciones
    oFuncDirectory.oFunctions.insert("main".to_string(), oFunctionInfoMain);

    for (sFuncName, oFunctInfo) in funcs {
        if oFuncDirectory.oFunctions.contains_key(&sFuncName) {
            panic!("Function '{}' already declared", sFuncName); // Validación
        }      
        oFuncDirectory.oFunctions.insert(sFuncName, oFunctInfo);
    }


    //Box::new(oFuncDirectory)
    ()

  }
}

//Header Inicial
Header: String = {
  "program" <id:"identifier"> ";" => {
    format!("ProgramDeclaration({})", id)
  }
}

// Body
Body: Vec<String> = {
  "{" <state:DecStatement> "}" => {
    let v = state;
    v
  }
}

// Statement

DecStatement: Vec<String> = {
  => vec![],
  <assign:Assign><ds:DecStatement> => vec![assign],
  <condition:Condition><ds:DecStatement> => vec![condition],
  <cycle:Cycle><ds:DecStatement> => vec![cycle],
  <fCall:FCall><ds:DecStatement> => vec![fCall],
  <print:Print><ds:DecStatement> => vec![print]

}

Assign: String = {
  <id: "identifier"> "=" <exp:Expresion> ";" => {
    format!("Asignacion( {})", id)
  }
}

Condition: String = {
  "if" "(" <exp:Expresion> ")" "do" <b:Body> <e:Else> ";" => {
    format!("Condicion( {})",  e )
  }
}

Else: String = {
  => "None Else".to_string(),
  "else" <b:Body> => format!("Else()")
}

Cycle: String = {
  "while" "(" <exp:Expresion> ")" "do" <b:Body> ";" => {
    format!("Cycle()")
  }
}

FCall: String = {
  <id: "identifier"> "(" <de:DecExpresion> ")" ";"=> {
    format!("FCall({})", id)
  }
}

Print: String = {
  "print" "(" <pt:PrintTipo> ")" ";"=> {
    format!("Print({})", pt)
  }
}

PrintTipo: String = {
  <exp:Expresion><pe:PrintExtra> => {
      "Expresion".to_string()
  },
  <val:"cte.string"> <pe:PrintExtra> => {
     "String".to_string()
  }
}

PrintExtra: String = {
  => "".to_string(),
  "," <print:PrintTipo> => {
     print
  }
}

// Variables

pub DecVars: Vec<(String,Box<DataType>)> = {
  => vec![],
  <var:Vars> <rest:DecVars> => {
    let mut v = var;
    v.extend(rest);
    v
  }
}

Vars: Vec<(String, Box<DataType>)> = {
  "var" <vars:Variable> ":" <tpe:Type> ";" => {
    //Para cada id de vars va a generar un valor en el vector con (id, type)
    vars.into_iter().map(|id| (id, tpe.clone())).collect()
  }
}


Variable: Vec<String> = {
  <name:"identifier"> <more:MASIDS> => {
    let mut ids = vec![name];
    ids.extend(more);
    ids
  }
}

MASIDS: Vec<String> = {
  => vec![],
  "," <name:"identifier"> <more:MASIDS> => {
    let mut ids = vec![name];
    ids.extend(more);
    ids
  }
}


// Funciones

// Funciones: cero o más (Nombre, Info Funcion)
pub DecFuncs: Vec<(String, FunctionInfo)> = {
  => vec![],
  <func:Funcs> <rest:DecFuncs> => {
    let mut v = func;
    v.extend(rest);
    v
  }
}

// Una función (Nombre, Info Funcion)
Funcs: Vec<(String, FunctionInfo)> = {
  "void" <name:"identifier"> "(" <params:DecParametros> ")" "[" <vars:DecVars> <body:Body> "]" ";" => {
    //format!("DeclaracionFuncion({}, {:?}, {:?}, {:?})", name, params, vars, body)
    let mut oFunctionInfo = FunctionInfo::new("void".to_string());
    let mut v = params;
    v.extend(vars);
    // Declaracion parametros y variables dentro de funcion
    for (sName, oType) in v {
        if oFunctionInfo.oVariableDirectory.contains_key(&sName) {
            panic!("Variable '{}' already declared", sName); // Validación
        }      

        oFunctionInfo.oVariableDirectory.insert(sName, usize::MIN);
    }

    vec![(name,oFunctionInfo)]
  }
}

// Parametros

DecParametros: Vec<(String, Box<DataType>)> = {
  => vec![],
  <p:Param> <rest:MASPARAMS> => {
    let mut v = p;
    v.extend(rest);
    v
  }
}

Param: Vec<(String, Box<DataType>)> = {
  <id:"identifier"> ":" <tpe:Type> => {
    vec![(id, tpe)]
  }
}

MASPARAMS: Vec<(String, Box<DataType>)> = {
  => vec![],
  "," <p:Param> <rest:MASPARAMS> => {
    let mut v = p;
    v.extend(rest);
    v
  }
}


DecExpresion: Vec<Expression> = {
  => vec![],
  <exp:Expresion> <rest:MASEXPRESIONES> => {
    let mut v = vec![exp];
    v.extend(rest);
    v
  }
}

MASEXPRESIONES: Vec<Expression> = {
  => vec![],
  "," <exp:Expresion> <rest:MASEXPRESIONES> => {
    let mut v = vec![exp];
    v.extend(rest);
    v
  }
}


// Expresion 
Expresion: Expression = {
    <lhs:EXP> <rel:TipoExp> => match rel {
        Some((op, right)) => Expression::BinaryOperation {
            left: Box::new(lhs),
            operator: op,
            right: Box::new(right),
        },
        None => lhs,
    },
};


// Operadores relacionales
TipoExp: Option<(Operator, Expression)> = {
    => None,
    ">" <exp:EXP> => Some((Operator::GreaterThan, exp)),
    "<" <exp:EXP> => Some((Operator::LessThan, exp)),
    "!=" <exp:EXP> => Some((Operator::NotEqual, exp)),
};

// Expresión aritmética básica
EXP: Expression = {
  <lhs:Termino> <rhs:TerminoDerecha> => {
    match rhs {
      Some((op, right)) => Expression::BinaryOperation{ left: Box::new(lhs),
            operator: op,
            right: Box::new(right),
            },
      None => lhs
    }
  }
}

// Un solo término
Termino: Expression = {
    <lhs:Factor> <rhs:FactorDerecha> => match rhs {
        Some((op, right)) => Expression::BinaryOperation {
            left: Box::new(lhs),
            operator: op,
            right: Box::new(right),
        },
        None => lhs,
    },
};


TerminoDerecha: Option<(Operator, Expression)> = {
    => None,
    "+" <t:Termino> => Some((Operator::Add, t)),
    "-" <t:Termino> => Some((Operator::Sub, t)),
};


FactorDerecha: Option<(Operator, Expression)> = {
    => None,
    "*" <f:Factor> => Some((Operator::Mul, f)),
    "/" <f:Factor> => Some((Operator::Div, f)),
};


// Factores
Factor: Expression = {
    "(" <e:Expresion> ")" => e,
    <sign:FactorSigno> <val:FactorValor> => match sign {
        Some(operator) => Expression::UnaryOperation { operator, expr: Box::new(val) },
        None => val,
    },
};


FactorSigno: Option<Operator> = {
    => None,
    "+" => Some(Operator::Add),
    "-" => Some(Operator::Sub),
};


// Identificador o constante
FactorValor: Expression = {
    <id:"identifier"> => Expression::Identifier(id.to_string()),
    <cte:CTE> => cte,
};


// Constantes
pub CTE: Expression = {
  <i:"int"> => Expression::Constant(Value::Int(i)),
  <f:"float"> => Expression::Constant(Value::Float(f)),
}

// Tipos
pub Type: Box<DataType> = {
  "KeywordInt" => Box::new(DataType::Int),
  "KeywordFloat" => Box::new(DataType::Float),
}

// // Expresiones aritméticas
// pub Expression: Box<ast::Expression> = {
//   #[precedence(level="1")]
//   Term,

//   #[precedence(level="2")] #[assoc(side="left")]
//   <lhs:Expression> "*" <rhs:Expression> => {
//     Box::new(ast::Expression::BinaryOperation {
//       lhs,
//       operator: ast::Operator::Mul,
//       rhs
//     })
//   },
//   <lhs:Expression> "/" <rhs:Expression> => {
//     Box::new(ast::Expression::BinaryOperation {
//       lhs,
//       operator: ast::Operator::Div,
//       rhs
//     })
//   },

//   #[precedence(level="3")] #[assoc(side="left")]
//   <lhs:Expression> "+" <rhs:Expression> => {
//     Box::new(ast::Expression::BinaryOperation {
//       lhs,
//       operator: ast::Operator::Add,
//       rhs
//     })
//   },
//   <lhs:Expression> "-" <rhs:Expression> => {
//     Box::new(ast::Expression::BinaryOperation {
//       lhs,
//       operator: ast::Operator::Sub,
//       rhs
//     })
//   },
// }

// // Literales y variables
// pub Term: Box<ast::Expression> = {
//   <val:"int"> => {
//     Box::new(ast::Expression::Integer(val))
//   },
//   <name:"identifier"> => {
//     Box::new(ast::Expression::Variable(name))
//   },
//   "(" <e:Expression> ")" => e,
// }
